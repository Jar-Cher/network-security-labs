# 1. Network application

**Цель работы:** Освоение набора системных вызовов для создания
socket-соединений различных типов для обмена данными на хостах и по сети.

*См. отчет по предмету "Операционные системы*

# 2. L4 Socket sample

**Цель работы:** Создание клиент-серверных приложений, взаимодействующих
друг с другом по сети на основе технологии соединения на сокетах L4.

*См. отчет по предмету "Операционные системы*

# 3. GnuPG tool utilisation 1

## 1. Цель работы

Установка утилиты GnuPG, исследование ее режимов работы с различными опциями и ключами и выполнение команд из базового
списка.

## 2. Ход работы

Данная работа выполнялась на ОС Ubuntu 20.04.6 на WSL (Windows Subsystem for Linux).

![wsl](images/task-3/wsl.png)

## 3. Установка GNU PG2

Установим GNU PG2 (GPG2):

![installGPG](images/task-3/installGPG.png)

Выведем информацию о текущей версии GPG2:

![versionGPG](images/task-3/version.png)

## 4. Генерация ключей

Сгенерируем ключи для шифрования и подписи (тип 1), размером 4096 и бесконечным временем жизни:

![creation](images/task-3/creation.png)

Убедимся в том, что ключ действительно создан и распознан GPG2:

![list-after-creation](images/task-3/list-after-creation.png)

Действительно, сгенерированный ключ появился в списке. Выведем отпечаток ключа – в дальнейшем он потребуется для
проверки корректности импорта ключа с сервера:

![fingerprint](images/task-3/fingerprint.png)

Проверим структуру папки `.gnupg` после генерации ключей. Для этого воспользуемся утилитой `tree`, которая строит
файловую структуру заданной папки в удобном визуальном формате:

![gpg-dir](images/task-3/gpg-dir.png)

В полученной структуре можно заметить следующие объекты:

- Каталог, хранящий в себе открытые ключи (`opengp-revocs.d`);
- Каталог, хранящий в себе приватные ключи (`private-keys-v1.d`);
- Зашифрованный файл - связку открытых ключей (`pubring.kbx`);
- Файл с доверительной базой данных (`trustdb.gpg`).

## 5. Шифрация и дешифрация файла

Создадим документ с произвольным текстом для дальнейшей работы с ним:

![orig-text-creation](images/task-3/orig-text-creation.png)

Зашифруем созданный файл созданным ранее ключом:

![orig-text-encrypted](images/task-3/orig-text-encrypted.png)

Дешифруем полученный файл тем же ключом, сравним исходный и полученный файлы:

![orig-text-decrypted](images/task-3/orig-text-decrypted.png)

Различий между исходным файлом и результирующим файлом нет, что свидетельствует об успешном процессе шифрации и
дешифрации.

## 6. Создание цифровой подписи

Создадим новый файл, сгенерируем к нему цифровую подпись:

![orig2-text-key](images/task-3/orig2-text-key.png)

Проверим полученную цифровую подпись:

![orig2-text-verification](images/task-3/orig2-text-verification.png)

Полученный результат "Good signature" свидетельствует о том, что подписанному документу был найден соответствующий ключ
из хранилища.

## 7. Исследование прочих команд GPG2

При помощи GPG2 возможна и более тонкая настройка ключа при его создании при добавлении флага `--expert`. Попробуем
создать ещё один ключ подобным образом:

![expert-creation](images/task-3/expert-creation.png)

Очевидно, что помимо добавления и создания ключей доступна операция их удаления из хранилища. Попробуем удалить
созданные нами ключи в правильном порядке: сначала приватные, затем связанные с ними публичные:

![expert-removal](images/task-3/expert-removal.png)

## 8. Выводы

В рамках данной работы были изучены основы работы с GPG: создание и удаления пар ключей (публичный/приватный),
шифрация и дешифрация файлов при помощи ключей, создание электронной подписи файла и её проверка.

# 4. GnuPG tool utilisation 2

## 1. Цель работы

Импорт и экспорт ключей (цифровых подписей), шифрование сообщений с помощью цифровых подписей.

## 2. Ход работы

Данная работа выполнялась на ОС Ubuntu 20.04.6 на WSL (Windows Subsystem for Linux).

![wsl](images/task-3/wsl.png)

## 3. Создание и использование электронной цифровой подписи (ЭЦП)

Шифрация файлов и проверка подписей может осуществляться при помощи открытого ключа. Для дальнейшей работы используется
ключ, созданный в предыдущей лабораторной работе:

![created-key](images/task-4/created-key.png)

Экспортируем данный ключ во внешний файл:

![exported-key](images/task-4/exported-key.png)

Создадим новый файл для дальнейшей работы с ним:

![orig3-text-creation](images/task-4/orig3-text-creation.png)

Создадим для него отсоединённую ЭЦП в текстовом формате:

![orig3-text-sign-detached](images/task-4/orig3-text-sign-detached.png)

Аналогичным образом, создадим отсоединённую ЭЦП в бинарном формате:

![orig3-text-bin-sign-detached](images/task-4/orig3-text-bin-sign-detached.png)

После выполнения команды произошло создание файла ЭЦП `originalText3.txt.sig`, который и является отсоединённой ЭЦП.

Создадим встроенную в файл ЭЦП в текстовом формате:

![orig3-text-sign-attached](images/task-4/orig3-text-sign-attached.png)

Аналогичным образом, создадим встроенную ЭЦП в бинарном формате:

![orig3-text-bin-sign-attached](images/task-4/orig3-text-bin-sign-attached.png)

После выполнения команды произошло создание файла `originalText3.txt.gpg`.

## 4. Импорт и экспорт ключей

Предварительно отчистив хранилище ключей, импортируем созданный ранее ключ и убедимся в корректности его импорта:

![imported-key](images/task-4/imported-key.png)

Отредактируем импортированный ключ - установим к нему доверие, что потребуется для дальнейшей проверки ЭЦП:

![entrusted-key](images/task-4/entrusted-key.png)

Теперь, при наличии импортированного доверенного ключа, проверим отсоединённую ЭЦП из предыдущего пункта:

![verification-text](images/task-4/verification-text.png)

Полученный результат - Good signature - свидетельствует о том, что ключ соответствует использованному при генерации ЭЦП.

Экспортируем этот же ключ на внешний сервер keyserver.ubuntu.com, убедимся в том, что ключ действительно находится на
сервере:

![exported-keyserver](images/task-4/exported-keyserver.png)

Первая полученная ошибка может быть объяснена тем, что сервер не успел так быстро обработать полученный ключ - поэтому
первый запрос ключа закончился получением ошибки, а второй прошёл успешно.

Импортируем экспортированный ранее ключ:

![imported-keyserver](images/task-4/imported-keyserver.png)

Полученный с сервера ключ соответствует имеющемся, о чём говорит строка unchanged: 1 в результате.

## 5. Выводы

В рамках данной работы были изучены основные способы генерации встроенных и отсоединённых ЭЦП при помощи GPG2. Также был
получен практический опыт по импорту и экспорту ключей как в отдельный файл, так и на внешний сервер.

# 5. WireShark packet sniffing

## 1. Цель работы

Изучение основных способов поиска уязвимостей в сети по анализу сетевого трафика с помощью программы анализатора
Wireshark.

## 2. Ход работы

Данная работа осуществлялись на машине, подключенной к домашней сети со следующей конфигурацией:

- Локальный IPv6-адрес канала: `fe80::3a0e:bb5b:597d:e57b%11`
- IPv4-адрес: `192.168.1.38`
- Маска подсети: `255.255.255.0`
- Основной шлюз: `192.168.1.1`
- MAC-адрес: `28-D0-EA-DE-DB-CC`

## 3. Анализ ICMP-трафика

Протокол ICMP (Internet Control Message Protocol) предназначен для решения задач управления, тестирования, мониторинга
сети и нотификации об ошибках и проблемах связанных с сетью.

Трафик протокола ICMP порождается такими утилитами как например `ping` или `traceroute`.

### 3.1 ping

Утилита `ping` отправляет запросы (Echo-Request) протокола ICMP указанному узлу сети и фиксирует поступающие ответы
(Echo-Reply). Время между отправкой запроса и получением ответа (RTT) позволяет определять двусторонние задержки по
маршруту и частоту потери пакетов, т.е. косвенно определять загруженность на каналах передачи данных и промежуточных
устройствах.

Wireshark — программа-анализатор трафика компьютерных сетей. Данная программа может отслеживать весь сетевой трафик
в режиме реального времени, переводя сетевую карту в promisc mode (принятие всех сетевых пакетов вне зависимости от их
адресата). Т.к. ICMP является сетевым протоколом, то Wireshark может отслеживать соответствующий трафик.

Для того чтобы отследить ICMP-трафик, требуется предварительно запустить отслеживание пакетов в Wireshark.

Для генерации ICMP трафика использовалась команда `ping github.com`:

![ping.png](images/task-5/ping.png)

Было отправлено 4 эхо-запроса и получено 4 эхо-ответа. Соответствующий трафик был отслежен в Wireshark:

![ping-wireshark.png](images/task-5/ping-wireshark.png)

В отчете Wireshark видно 8 пакетов, о каждом из которого приведена краткая информация:

- IP-адрес отправителя пакета;
- IP-адрес получателя пакета;
- используемый протокол передачи данных;
- длинна пакета данных;
- информация, специфичная для используемого протокола.

Для каждого отслеженного пакета можно посмотреть более детальную информацию:

![echo-request.png](images/task-5/echo-request.png)

В детальном отчете о первым пакете можно увидеть следующую информацию:

- IP-адрес отправителя пакета: `192.168.1.38`;
- IP-адрес получателя пакета: `140.82.121.3`;
- количество хопов до получателя (ttl): `128`;
- тип протокола пакета: `ICMP`;
- тип icmp-пакета: `8` (пакет является эхо-запросом);
- код (подтип ICMP пакета): `0` (не важен для эхо-запросов);
- идентификатор (используется для сопоставления запроса с ответом): `1`;
- номер последовательности (используется для сопоставления запроса с ответом): `61`;
- контрольная сумма (используется для проверки ошибок передачи данных): `0x4d1e`.

Следом за эхо-запросом в отчете Wireshark можно увидеть пакет с соответствующим эхо-ответом:

![echo-reply.png](images/task-5/echo-reply.png)

В детальном отчете о втором пакете можно увидеть следующую информацию:

- IP-адрес отправителя пакета: `140.82.121.3`;
- IP-адрес получателя пакета: `192.168.1.38`;
- количество хопов до получателя (ttl): `53`;
- тип протокола пакета: `ICMP`;
- тип icmp-пакета: `0` (пакет является эхо-ответом);
- код (подтип ICMP пакета): `0` (не важен для эхо-ответов);
- идентификатор (используется для сопоставления запроса с ответом): `1`;
- номер последовательности (используется для сопоставления запроса с ответом): `61`;
- контрольная сумма (используется для проверки ошибок передачи данных): `0x551e`;
- время ответа: `41.74`.

### 3.2 tracert

Другой утилитой, использующей ICMP-протокол является `tracert`, предназначенная для определения маршрута к узлу с
заданным IP-адресом, посылая на него соответствующие эхо-запросы. В этих пакетах tracert использует разные значения
Time To Live (TTL). Поскольку каждый маршрутизатор на пути пакета уменьшает значение его поля TTL минимум на 1 перед
дальнейшей пересылкой пакета, значение TTL можно считать счетчиком переходов. Когда срок жизни пакета достигает нуля,
маршрутизатор отправляет ICMP-пакет с сообщением об истечении TTL на исходный компьютер. Отправитель получает данное
сообщение с IP-адресом хоста, на котором истек TTL. Так, инкрементируя значение TTL начиная с 1, последовательно
отправляются эхо-запросы до тех пор, пока один из них не достигнет адресата.

Для генерации трафика использовалась команда `tracert github.com`:

![tracert.png](images/task-5/tracert.png)

В отчете Wireshark видно множество пакетов

![tracert-wireshark.png](images/task-5/tracert-wireshark-1.png)

![tracert-wireshark.png](images/task-5/tracert-wireshark-2.png)

В общей сложности было зафиксировано 73 пакета (42 отправлено и 31 получено).

Далее детально рассматриваются некоторые пакеты:

![tracert-request-1.png](images/task-5/tracert-request-1.png)

1 пакет является исходящим, имеет тип 8 (эхо-запрос) и, как и ожидалось, его TTL равен 1.

![tracert-reply-1.png](images/task-5/tracert-reply-1.png)

2 пакет является входящим и имеет тип 11 (истек TTL). При этом отправителем является хост с IP-адресом 192.168.1.1,
т.е. это маршрутизатор домашней сети.

Следующие 4 пакета являются абсолютно аналогичными первым двум, т.к. `tracert` отправляет 3 запроса с одинаковым TTL в
качестве контрольных выстрелов в голову.

![tracert-request-2.png](images/task-5/tracert-request-2.png)

7 пакет является аналогичным 1 пакету, но его TTL равен 2.

![tracert-reply-2.png](images/task-5/tracert-reply-2.png)

8 пакет является аналогичным 2 пакету, но его IP-адрес отправителя является `10.145.63.1`.

Не сложно догадаться, что далее процедура продолжается: отправляется 3 эхо-запроса с одним TTL, TTL инкриминируется, и
так происходит до тех пор, пока ответы на эхо-запросы начнет отправлять непосредственный адресат запросов.

![tracert-request-3.png](images/task-5/tracert-request-3.png)

Один из последних пакетов (67) имеет TTL равный 14.

![tracert-reply-3.png](images/task-5/tracert-reply-3.png)

Пакет с ответом на этот запрос (68) имеет уже тип 8 – эхо-ответ, а IP-адрес отправителя – `140.82.121.3`, т.е. IP-адрес
домена `github.com`, что означает, что запрос достиг своей цели.

Последние 4 пакета являются контрольными парами запрос-ответов с таким же TTL.

Отправленных пакетов больше, чем полученных из-за того, что хосты на самом деле не обязаны отправлять что-либо при
истечении TTL, т.е. на часть запросов просто не приходило ответов.

## 4. Анализ ARP-трафика

Для передачи данных внутри сети хост должен знать MAC-адрес хоста, которому передаются данные. Для получения МАС-адреса
по известному IP-адресу используется протокол ARP, который работает в режиме запрос-ответ: запрос отправляется на
широковещательный адрес, после чего каждый хост в подсети получает этот запрос и проверяет на соответствие свой
IP-адрес, и при совпадении посылает ARP-ответ непосредственно отправителю, используя его MAC-адрес. Целью протокола ARP
является заполнение ARP-таблицы: на
приемной стороне при получении ARP-запроса, на запрашивающей стороне при получении ответа.

Для начала нужно определить, кому внутри домашней сети можно отправить ARP-запрос. Посмотреть это можно в графическом
web-интерфейсе маршрутизатора сети:

![connected-devices.png](images/task-5/connected-devices.png)

В сети имеется множество клиентов, в том числе и используемый хост с адресом `192.168.1.38`.

Попробуем определить MAC-адрес хоста с адресом `192.168.1.33`. Чтобы узнать MAC-адрес хоста, требуется отправить
ARP-запрос. Для этого можно воспользоваться командой `ping 192.168.1.33`, которая сформирует широковещательный
ARP-запрос, который можно отследить в Wireshark:

![ping-arp-wireshark.png](images/task-5/ping-arp-wireshark.png)

Было зафиксировано 2 запроса c типом протокола ARP.

![arp-broadcast.png](images/task-5/arp-broadcast.png)

Первый пакет имеет информацию об отправителе (IP- и MAC-адреса) и IP-адрес хоста, MAC-адрес которого
требуется узнать (при этом MAC-адрес цели заполнен нулями). Также, как пакет протокола ARP, в нем
содержится поле Opcode равное 1, что означает широковещательный ARP-запрос. И действительно, в качестве получателя в
пакете указан широковещательный MAC-адрес `ff:ff:ff:ff:ff:ff`.

![arp-broadcast-reply.png](images/task-5/arp-broadcast-reply.png)

Второй пакет имеет Opcode 2, обозначающий ответ на широковещательный ARP-запрос, информацию о своем отправителе,
включая IP- и MAC-адрес (IP-адрес в данном случае тот же, на который посылался ARP-запрос, и который собственно
ожидался), и IP- и MAC-адрес получателя (в данном случае совпадает с данными хоста, с которого посылался запрос).

## 5. Анализ FTP-трафика

FTP (File Transfer Protocol) — протокол передачи файлов, который применяется для обмена файлами по TCP/IP сетям между
двумя компьютерами: клиентом и сервером. Используется транспорт TCP и передача текстовых команд, то есть в одну сторону
отправляются текстовые команды с параметрами, а в обратную сторону передаются текстовые ответы со статусами.
Поддерживается активный и пассивный режимы взаимодействия.

Соединяясь с FTP сервером допустимо пройти авторизацию предоставляя данные для входа, а также можно подключиться
анонимно, если это позволяет FTP сервер.

Основное назначение FTP протокола — это загрузка файлов и их скачивание с удалённого сервера. Для передачи файлов в
активном режиме организуется канал команд со стороны клиента, и создаётся соединение с 21 портом сервера. Когда
потребуется передача данных, сервер самостоятельно с 20 номера порта организует связь с клиентским сокетом, то есть
второй канал для данных. Данные при этом могут посылаться в обе стороны. В пассивном режиме схема похожая с активным,
только канал связи (данных) открывает 52 клиент. Номер порта у сервера каждый раз выбирается новым, и информация об этом
порте передаётся клиенту.

Подключение будет производиться к FTP-серверу `test.rebex.net` по адресу `194.108.117.16` при помощи программы WinSCP.

![ftp-tcp-connection.png](images/task-5/ftp-tcp-connection.png)

В отчете Wireshark можно видеть сегменты установления TCP-соединения. Порт клиента – 21970, а сервера – 21.

![ftp-login.png](images/task-5/ftp-login.png)

Далее в отчете следуют пакеты, смысл которых можно описать как процесс аутентификации.

- получение FTP-сообщения с кодом 220;
- отправка логина;
- получение запроса пароля;
- отправка пароля;
- получение сообщения об успешной аутентификации.

![ftp-220.png](images/task-5/ftp-220.png)

1 пакет был входящим, имел имя FTP сервера и код FTP 220, который означает готовность сервера для идентификации нового
пользователя.

![ftp-user-data.png](images/task-5/ftp-user-data.png)

2 пакет был исходящим, имел имя пользователя для аутентификации.

![ftp-password-required.png](images/task-5/ftp-password-required.png)

3 пакет был входящим, имел сообщение о запросе пароля для аутентификации.

![ftp-password-data.png](images/task-5/ftp-password-data.png)

4 пакет был исходящим, имел пароль для аутентификации.

![ftp-login-success.png](images/task-5/ftp-login-success.png)

5 пакет был входящим, имел код FTP 230, который означает успешную аутентификацию пользователя.

## 6. Повышение безопасности FTP-соединения

Для повышения безопасности соединения было решено добавить в настройках подключения WinSCP явное шифрование TLS/SSL:

![ftp-winscp-settings.png](images/task-5/ftp-winscp-settings.png)

![ftp-tls.png](images/task-5/ftp-tls.png)

Теперь вместо идентификации поступает запрос “AUTH TLS”, который переводит FTP-сервер в режим согласования TLS. Далее
клиент уже по протоколу TLS отправляет спецификацию в виде обычного текста, а именно версию протокола, которую он хочет
использовать, поддерживаемые методы шифрования, и т.д. В свою очередь сервер утверждает версию используемого протокола,
выбирает способ шифрования из предоставленного списка, прикрепляет свой сертификат и отправляет ответ клиенту. Версия
протокола и способ шифрования на данном моменте считаются утверждёнными, клиент проверяет присланный сертификат и
инициирует обмен ключами по Диффи-Хеллману. После этого сервер обрабатывает присланное клиентом сообщение, сверяет MAC,
и отправляет клиенту заключительное `Finished` сообщение в зашифрованном виде. Клиент же расшифровывает полученное
сообщение, сверяет MAC, и соединение считается установленным, после чего начинается обмен данными приложений.

## 7. Анализ Telnet и SSH трафика

### 7.1 SSH

Для подключения по SSH использовалась команда `ssh -T git@github.com`. При этом предварительно была сгенерирована пара
ключей, и публичный ключ был добавлен в GitHub. Передача данных осуществлялась по протоколу SSHv2, который передает
данные в зашифрованном виде.

![ssh-wireshark.png](images/task-5/ssh-wireshark.png)

Из отчета Wireshark видно, что сначала осуществляется конфигурация используемых для обмена данными ключей для шифровки,
а затем начинается сама зашифрованная передача данных.

![ssh-wireshark-example.png](images/task-5/ssh-wireshark-example.png)

Как видно в детальной информации о пакете с данными, прочитать сами данные Wireshark не смог.

### 7.2 Telnet

Подключение по Telnet производилось к маршрутизатору домашней сети при помощи программы PuTTY. IP-адрес: `192.168.1.36`;
порт: `23` (используется Telnet по умолчанию для установки соединения).

![telnet.png](images/task-5/telnet.png)

Подключившись к серверу, пройдя аутентификацию и выполнив пару команд, был полученный длинный отчет в Wireshark.

![telnet-wireshark.png](images/task-5/telnet-wireshark.png)

Как видно в детальном отчете, каждый пакет передается в открытом виде. Например, был найден пакет, передающий ответ на
запрос о текущей версии ОС.

## 8. Анализ TCP и UDP трафика

### 8.1 TCP

TCP (Transmission Control Protocol) – протокол транспортного уровня, реализующий надежную доставку потока данных путём
предварительного установления соединения. Имеет большую надёжность, реализуется за счёт квитирования, то есть при помощи
пакета-уведомление, который сигнализирует о том, что соответствующий пакет был получен.

Установка TCP соединения происходит в 3 этапа:

- Запрашивающая сторона (клиент) отправляет сегмент с флагом SYN, указывая номер порта сервера, к которому клиент хочет
  подсоединиться, и исходный номер последовательности клиента (предыдущий номер в буфере);
- Сервер отсылает флаг ACK с номером подтверждения принятого только что сегмента + 1 и флаг SYN также с номером очереди
  сегмента, только уже для этой стороны;
- В ответ на это клиент отправляет флаг ACK с номером принятого только что сегмента + 1.

При помощи команды `nslookup jetbrains.com` был получен IP-адрес для подключения по протоколу TCP:

![nslookup.png](images/task-5/nslookup.png)

Для установки TCP-соединения по IP-адресу `13.33.243.77` и порту `80` использовалась программ PuTTY.

Wireshark отследил следующие пакеты:

![tcp-wireshark.png](images/task-5/tcp-wireshark.png)

При подключении фигурирует 3 пакета:

- `SYN`
- `SYN`, `ACK`
- `ACK`

![tcp-connection-1.png](images/task-5/tcp-connection-1.png)

Первый пакет, который отправлен на IP-адрес `13.33.243.77`, содержит флаг `SYN`. Серверный порт – `80`, а клиентский –
`50901`, то есть непривилегированный номер порта, который выдаётся ОС. Номер последовательности и подтверждения равны 0.

![tcp-connection-2.png](images/task-5/tcp-connection-2.png)

Второй пакет, который является ответом сервера на первый, имеет флаги `SYN` и `ACK`. Номер последовательности на стороне
сервера равен 0, а номер подтверждения равен номеру последовательности клиента + 1, то есть единице.

![tcp-connection-3.png](images/task-5/tcp-connection-3.png)

Третий пакет, отправляемый клиентом, имеет флаг `ACK`. При этом номер последовательности на стороне клиента уже равен 1,
а номер подтверждения равен номеру последовательности сервера + 1, то есть единице.

После обмена этими тремя пакетами TCP-соединение считается установленным.

### 8.2 UDP

UDP в отличие от TCP это незащищенный протокол, предполагающий самостоятельное проектирование и реализацию механизмов
защиты от потери и переотправки пакетов. UDP не требует открывать соединение, и данные могут быть отправлены сразу же,
как только они подготовлены, что ускоряет процесс передачи данных. Таким образом, UDP лучше всего использовать в
клиент-серверных приложениях, которые работают с несколькими клиентами, отправляющими небольшие запросы/ответы и
получающими такие же короткие ответы от сервера.

Для генерации UDP трафика была использована команда `nslookup -type=A jetbrains.com`. Утилита `nslookup` обращается к
DNS-серверу, посылая при этом UDP-запросы:

![udp-nslookup-1.png](images/task-5/udp-nslookup-1.png)

Первый пакет с запросом `nslookup` типа A с IP-адреса `192.168.1.38` и порта `64787` был отправлен на DNS-серверу по
IP-адресу `8.8.8.8` на порт `53`.

![udp-nslookup-2.png](images/task-5/udp-nslookup-2.png)

В ответ был получен пакет с информацией о 4 IP-адресах, соответствующих домену `jetbrains.com`.

## 9. Выводы

В данной работе были изучены возможности программы Wireshark по анализу трафика сети. С помощью данной утилиты был
проанализированы пакеты нескольких протоколов, а также в некоторых случаях была рассмотрена их защищённость.

# 6. Nmap network scanning

## 1. Цель работы

Изучение возможностей утилиты Nmap.

## 2. Ход работы

## 3. Обычное использование Nmap

Для запуска Nmap в обычном режиме была использована команда `nmap github.com`:

![nmap.png](images/task-6/nmap.png)

С помощью DNS-сервера программа пытается определить соответствие имени сканируемому IP-адресу. Если операция прошла
успешно, то в самом начале Nmap указывает реальное имя компьютера. Как видно из рисунка, IP-адресу `140.82.121.3`
соответствует имя `github.com`. Далее Nmap отображает информацию о закрытых или заблокированных портах (Not shown 997
filtered ports), а затем выводит порты, имеющие другой статус, включая информацию о том, может ли он принимать различные
значения, которые будут свидетельствовать о предполагаемом сервисе, использующем этот порт и статусе порта, определенном
Nmap:

- open (открытый порт) — порт открыт, и служба принимает TCP или UDP-соединения по этому порту (данный порт наиболее
  уязвим для взлома);
- filtered — порт закрыт брандмауэром, иной блокирующей программой или службой (правила роутера, аппаратный брандмауэр и
  т.п.);
- closed — порт закрыт, так как нет службы или иной программы, прослушивающей этот порт на компьютере.

## 4. Сканирование на предмет наличия компьютера в сети

Самым простым является метод обнаружения работающих компьютеров с помощью режима ping. Для этого в командной строке
необходимо использовать флаг `-sP`.

![nmap-sp.png](images/task-6/nmap-sp.png)

Сетевой сканер Nmap послал ICMP эхо-запросы заданному IP-адресу, получил ответ, а значит, сканируемый хост работает,
что и отображается в качестве результата сканирования.

Однако большинство брандмауэров блокируют ICMP-запросы, поэтому, даже если хост активен, но он не принимает эхо-запросы,
Nmap сообщит, что компьютера в сети не существует.

## 5. Обнаружение с помощью SYN/ACK и UPD-пакетов

Если какой-либо сервис прослушивает порт, а Nmap пытается установить с ним соединение (отсылает пакет с флагом SYN),
в ответ сервис может послать пакет с флагами `SYN`/`ACK`, что подтвердит наличие хоста в сети. Но при отсутствии сервиса
по этому порту сервер посылает в ответ пакет с флагом RST, что также указывает на то, что по заданному IP-адресу хост
существует. Если в ответ на посланный пакет `SYN` от сервера ничего не пришло — это значит, что, либо хост активен, либо
трафик блокируется брандмауэром. Чтобы обойти блокировку брандмауэра, разработан еще один метод сканирования. Сканер
Nmap обычно посылает пакеты с флагами `SYN`/`ACK` и пакет UDP по стандартному порту `80`, который чаще всего
используется для web-трафика и поэтому очень редко блокируется брандмауэром. С помощью ключей `-PS`, `-PA` и `-PU` можно
задавать, какой пакет будет отправлен серверу и по какому порту.

![nmap-ps-pa-pu.png](images/task-6/nmap-ps-pa-pu.png)

## 6. Обнаружение компьютера посредством различных ICMP-пакетов

Сетевой сканер Nmap имеет еще одну возможность определения наличия компьютера в сети. Для того чтобы воспользоваться
этой функцией, необходимо указать дополнительные ключи:

- `-PE` – использует эхо-запросы

![nmap-pe.png](images/task-6/nmap-pe.png)

- `-PP` – использует запросы даты/времени

![nmap-pp.png](images/task-6/nmap-pp.png)

- `-PM` – использует адреса маски сети

![nmap-pm.png](images/task-6/nmap-pm.png)

С помощью этих методов тоже можно получить ответ от хоста, однако, как оказалось GitHub именно последние 2 способа
блокирует.

## 7. Методы сканирования портов удаленного компьютера

Сетевой сканер Nmap предполагает применение разнообразных методов сканирования и получения необходимой информации.
Однако очень многие методы задействуют различные манипуляции с флагами TCP-пакетов на низком уровне, а потому для работы
требуют полномочий суперпользователя в системе. Используемые методы могут функционировать только отдельно друг от друга,
лишь сканирование UDP-портов может осуществляться одновременно с другими методами сканирования. Сканирование портов
основывается на методе отправки пакетов с измененными флагами при инициации TCP- и UDP-соединений.

### 7.1 Сканирование методом SYN

Наиболее распространенный метод, который используется по умолчанию, – это сканирование `TCP SYN`. Для большинства
исследуемых компьютеров этого метода вполне достаточно, чтобы определить открытые порты. `TCP SYN` сканирование
наиболее быстрое по сравнению с другими методами. Оно позволяет сканировать сотни портов в секунду, сохраняя при
этом сканирующий хост скрытым для сети, поскольку никогда не завершает TCP-соединение (большинство утилит мониторинга
не регистрируют данные соединения). Для использования этого метода необходимы права суперпользователя. Сканер Nmap
отправляет исследуемому хосту пакет с флагом `SYN`, как будто он хочет открыть обычное TCP-соединение. Если ответ (пакет
с флагами `SYN/ACK`) от запрашиваемого хоста получен, порт будет обозначен как открытый, а при получении пакета с флагом
`RST` — как закрытый. В случае если сканируемый компьютер не ответил, предполагается, что этот порт фильтруется
брандмауэром. Чтобы использовать данный метод сканирования, необходимо запустить Nmap с ключом `-sS`:

![nmap-ss.png](images/task-6/nmap-ss.png)

### 7.2 Сканирование с использованием системной функции connect()

Бывают ситуации, когда полномочия суперпользователя отсутствуют, а просканировать удаленный компьютер необходимо. В этом
случае Nmap использует метод, основанный на установлении соединения с помощью системной функции `connect()`, которую
применяет большинство приложений — p2p-клиенты, браузеры и сетевые приложения. При этом Nmap посылает запрос самой
операционной системе, которая и устанавливает TCP-соединение. Если соединение установлено, то порт помечается как
открытый, а если нет — как закрытый. После определения статуса порта Nmap прерывает соединение, то есть с помощью
функции `connect()` посылается пакет с флагом `RST`. Однако такой метод имеет один недостаток: поскольку соединение
устанавливается полностью, оно остается в логах и журналах сканируемой системы, а потому системы по мониторингу
практически всегда определят, какой компьютер произвел сканирование. В связи с этим данный метод применяется редко.
Чтобы запустить вышеописанное сканирование, необходимо запустить Nmap с ключом `-sT`.

![nmap-st.png](images/task-6/nmap-st.png)

### 7.3 Сканирование портов UDP-протокола

Наиболее распространенные сервисы, использующие UDP-протокол, — это DNS, SNMP и DHCP. Поскольку сканирование протокола
UDP более сложное и медленное по сравнению с TCP-сканированием, многие защитные системы пренебрегают им и игнорируют
прослушивание (фильтрацию) этих портов. Но в таком случае сервисы, прослушивающие данные порты, тоже могут быть уязвимы
для взлома, так как Nmap позволяет определить, какие порты открыты и что за сервисы их прослушивают. Поскольку
UDP-протокол не похож на TCP, метод сканирования отличается от рассмотренных ранее. Nmap посылает UDP-пакет с пустым
заголовком по всем исследуемым портам и ждет ответа. Если в ответ он получает ICMP-пакет с ошибкой `unreachable error`,
порт считается закрытым. При получении пакетов с другими ошибками Nmap считает, что порт фильтруется брандмауэром.
Полученный ответный UDP-пакет свидетельствует о наличии сервиса, и порт обозначается открытым. Если ответ не получен
после нескольких попыток, Nmap помечает порт как `open|filtered`, поскольку не может точно установить — открыт ли порт
или брандмауэр блокирует трафик на этом порту. Кроме того, многие компьютеры могут посылать за секунду ограниченное
количество ICMP-сообщений с ошибками. Это сделано для защиты от перегрузки сети. Чтобы уточнить состояние порта, можно
использовать ключ `-sV` (в этом случае Nmap пытается определить запущенный по сканируемому порту сервис и его версию),
но тогда скорость сканирования снижается на порядок. UDP-сканирование может быть запущено одновременно с любыми из
методов TCP-сканирования, поскольку они применяют разные протоколы. Запуск UDP-сканирования происходит при указании
ключа `-sU`.

![nmap-su.png](images/task-6/nmap-su.png)

### 7.4 Сканирование с помощью методов FIN, Xmax и Null

Поскольку TCP-соединение базируется на трехходовом установлении связи, путем прерывания последовательности соединения
можно также получить информацию о закрытых и открытых портах исследуемого хоста. Существует метод `FIN` сканирования,
при котором удаленному хосту посылаются пакеты с флагом `FIN`, которые обычно применяются при закрытии соединения. В
этом случае закрытый порт хоста, в соответствии со спецификацией протокола TCP, должен послать ответный пакет с флагом
`RST`. Если же порт открыт или блокируется брандмауэром, ответа от него не будет. Как и в случае `SYN` сканирования,
соединение устанавливается не полностью, поэтому информации в системных логах исследуемого хоста может и не остаться, в
то же время большинство систем мониторинга могут зафиксировать этот тип сканирования. Данный метод является более
скрытным по сравнению с TCP connect-сканированием и позволяет определить, закрыт порт или открыт (блокируется), поэтому
существуют несколько модификаций этого метода. При использовании метода null-сканирования вместо пакета с `FIN` флагом
отсылается пакет с пустым заголовком (0 бит, все флаги отключены). Этот метод работает по вышеописанному принципу. Еще
один метод, имеющий схожий алгоритм работы, называется `Xmas` сканирование. В этом случае хосту отсылается пакет,
раскрашенный несколькими флагами (`FIN`, `PSH` и `URG`). Для каждого из рассмотренных методов существуют собственные
ключи: `-sN`, `-sF` и `-sX`.

![nmap-sn.png](images/task-6/nmap-sn.png)

![nmap-sf.png](images/task-6/nmap-sf.png)

![nmap-sx.png](images/task-6/nmap-sx.png)

Сравнивая результаты сканирования видно, что с их помощью все порты были определены как `open|filtred`.

### 7.5 Сканирование с помощью методов ACK и Window

Для определения, какие порты на компьютере находятся в статусе `filtered`, а какие в `unfiltered`, существует отдельно
вынесенный тип сканирования — `ACK`. Его также можно задействовать с помощью ключа `--scanflags ACK`. Поскольку многие
брандмауэры осуществляют просмотр лишь `SYN` пакетов на определенном порту, выполняя тем самым фильтрацию, с помощью
отсылки пакетов с флагом `ACK` с большой долей вероятности можно определить, существует ли на исследуемом компьютере
брандмауэр или нет. Пакет с флагом `ACK` в этом случае отсылается не как часть соединения, а отдельно. В случае если
принимающая сторона отсылает обратный пакет с флагом `RST` (соответственно порт не блокируется брандмауэром), порт
помечается как `unfiltered`, если же хост не отвечает на пакет, то на нем установлен брандмауэр и порт находится в
статусе filtered. Для активации этого метода необходимо запустить Nmap с ключом `-sA`.

![nmap-sa.png](images/task-6/nmap-sa.png)

У этого метода существует аналог, который работает по такому же принципу, но несколько иначе интерпретирует полученные
от хоста результаты. Сканирование методом TCP Window предполагает, что на некоторых хостах службы используют
положительное значение поля `window` в ответном пакете (не ноль). Поэтому с помощью данного метода Nmap анализирует
заголовки приходящих пакетов с флагом RST, и если приходящий пакет содержит положительное значение поля, то Nmap
помечает этот порт открытым. Получение пакета с нулевым значением поля означает, что порт закрыт. Чтобы активировать
этот метод сканирования, необходимо ввести ключ `-sW`.

![nmap-sw.png](images/task-6/nmap-sw.png)

### 7.6 Сканирование методом Maimon

Еще одним методом сканирования на основе трехходового соединения является метод, описанный специалистом по имени Uriel
Maimon. Его метод практически идентичен методам `FIN`, `Xmas` и `Null`, за исключением того, что посылаются пакеты с
флагами `FIN/ACK`. Здесь, если порт закрыт, хост должен отвечать пакетом `RST`. Чтобы активировать этот метод
сканирования, необходимо ввести ключ `-sM`.

![nmap-sm.png](images/task-6/nmap-sm.png)

### 7.7 Скрытое сканирование с использованием алгоритма idlescan

Ни один из рассмотренных методов не позволяет полностью скрыть IP-адрес сканирующего хоста. Поскольку подмена IP-адреса
исходящего пакета не так сложна, был найден метод сканирования, при котором исследуемый хост не может определить точного
IP-адреса хоста, с которого производится сканирование. Метод `idlescan` по своему алгоритму работы практически идентичен
`SYN` сканированию. Чтобы понять, каким образом при этом скрывается IP-адрес сканирующего компьютера, необходимо знать,
что каждый IP-пакет имеет свой номер (fragment identification number, IPID). Многие операционные системы увеличивают
этот номер для каждого следующего посланного пакета, поэтому можно легко определить, сколько пакетов послал хост. При
этом стоит учитывать, что если компьютер получил пакет с флагами `SYN/ACK` от адреса, у которого он соединения не
запрашивал, то в ответ он пошлет пакет с флагом `RST`. Этот метод предполагает использование еще одного хоста-зомби,
от имени которого будут идти пакеты к сканируемому компьютеру. Далее рассмотрим алгоритм работы `idlescan` метода.
Пусть сканирующий компьютер будет attacker, хост-зомби — zombie, а сканируемый компьютер — target.

Первый случай — исследуемый порт открыт:

- attacker посылает пакет с флагами `SYN/ACK` zombie, а в ответ zombie посылает пакет с флагом `RST`;
- attacker посылает пакет с флагом `SYN` по искомому порту от имени компьютера zombie;
- target посылает ответный запрос с флагами `SYN/ACK` компьютеру zombie. В ответ zombie посылает пакет с флагом `RST`
  хосту target, так как zombie не собирался устанавливать с ним соединение;
- attacker посылает пакет с флагом `SYN/ACK` компьютеру zombie, в ответ zombie посылает пакет с флагом `RST`.

Второй случай — порт закрыт:

- attacker посылает пакет с флагами `SYN/ACK` zombie, в ответ zombie посылает пакет с флагом `RST`;
- attacker посылает пакет с флагом `SYN` по искомому порту от лица компьютера zombie;
- target посылает пакет с флагом `RST` компьютеру zombie. В ответ zombie ничего не посылает;
- attacker посылает пакет с флагом `SYN/ACK` компьютеру zombie, в ответ zombie посылает пакет с флагом `RST`

Таким образом, путем простой арифметики можно вычислить, открыт или закрыт порт на исследуемом компьютере. Преимущество
данного способа заключается в том, что выявить IP-адрес сканирующего компьютера очень сложно, поскольку компьютер target
считает, что сканирование было произведено компьютером zombie, а запросы сканирующего компьютера остаются только в
журналах zombie. Чтобы активировать этот способ сканирования, необходимо ввести ключ `-sI <zombie-port>`, где zombie —
название или IP-адрес хоста, от лица которого будет производиться сканирование, а port — порт для связи сканирующего
хоста и zombie (по умолчанию 80-й, поскольку на большинстве компьютеров этот порт открыт для web-трафика).

![nmap-si-1.png](images/task-6/nmap-si-1.png)

![nmap-si-2.png](images/task-6/nmap-si-2.png)

### 7.8 Сканирование на наличие открытых протоколов

В некоторых случаях необходимо определить открытые протоколы на удаленном хосте. Поскольку каждому IP-протоколу
транспортного уровня присвоен собственный порядковый номер, а каждый IP-пакет имеет поле `protocol`, которое указывает
на тип заголовков пакетов и номер протокола, можно узнать, какие протоколы открыты на исследуемом хосте. Для определения
доступности протокола на хосте Nmap посылает несколько пакетов с пустыми заголовками, содержащими в поле `protocol`
только номер протокола. В случае, если протокол недоступен, компьютер вернет ICMP-сообщение "protocol unreachable".
Если в ответ хост не посылает пакетов — это может означать, что, либо протокол доступен, либо брандмауэр блокирует
ICMP-трафик. Такая ситуация очень схожа с UDP-сканированием, где также невозможно точно определить, открыт порт или
фильтруется брандмауэром. Чтобы активировать сканирование протоколов, необходимо задействовать ключ `-sO`.

![nmap-so.png](images/task-6/nmap-so.png)

## 8 Определение версий запущенных служб

Nmap может идентифицировать версии запущенных на удаленном ПК сервисов, при условии, что порты того или иного сервиса
открыты. Определение сервисов поможет получить более четкое представление, насколько уязвим исследуемый компьютер и
какие дыры в сервисах могут оставаться открытыми для взлома. Чтобы получить информацию о версии запущенного сервиса,
Nmap пользуется своей базой данных, которая включает специфические метки, свойственные именно этой версии программного
обеспечения. Сбор информации происходит после любого сканирования с любым методом анализа открытых портов. Определение
версий программ не всегда дает положительный результат, однако в большинстве случаев информация, полученная таким
способом, помогает составить представление об используемой системе на удаленном компьютере. В случае, если Nmap получает
информацию о хосте, но не может сопоставить ее с конкретным описанием в своей базе данных, программа выводит результат
на экран.

![nmap-version-all.png](images/task-6/nmap-version-all.png)

## 9. Определение версии ОС на удаленном компьютере

Одной из самых интересных опций является определение операционной системы удаленного компьютера. В этом случае
применяется модернизированный метод, предназначенный для определения версий запущенных служб. Nmap производит различные
тесты, посылая пакеты по разным протоколам с различными условиями на исследуемый компьютер. Сравнивая полученные
результаты с эталонными значениями, указанными в файле `Nmap-os-fingerprints`, программа выдает сводный результат по
компьютеру. В зависимости от количества и качества полученной информации, Nmap может определить производителя ОС, ее
примерную версию и тип оборудования, поскольку не всегда конечным результатом сканирования является компьютер — это
может быть также роутер, управляемый коммутатор и т.п. Для того чтобы активировать этот метод сканирования, необходимо
указать флаг `-O`, а также флаг `-A`, который активизирует определение версии операционной системы и версий запущенных
служб.

![nmap-ao-1.png](images/task-6/nmap-ao-1.png)

![nmap-ao-2.png](images/task-6/nmap-ao-2.png)

![nmap-ao-3.png](images/task-6/nmap-ao-3.png)

![nmap-ao-4.png](images/task-6/nmap-ao-4.png)

![nmap-ao-5.png](images/task-6/nmap-ao-5.png)

## 10. Настройки временных задержек

Высокая скорость работы определяется временными параметрами ответов и посылки пакетов. По умолчанию, чтобы получить
правдоподобные результаты сканирования, Nmap использует наиболее эффективные параметры времени. Однако специалистам
безопасности, которые пользуются этим сканером, для определенных методов сканирования могут понадобиться специальные
установки временных констант. В связи с этим разработчики Nmap предусмотрели установку некоторых констант вручную, а
также возможность задать «расписание» сканирования. Некоторые ключи используют установку времени, которое по умолчанию
вводится в миллисекундах, однако существует возможность записи времени в виде `s`, `m` и `h` — эти буквенные аргументы
добавляются в конец числового значения, значительно сокращая запись и упрощая ее. Например, `600000`, `600s`, `10m`
обозначают одно и то же время.

![performance-config.png](images/task-6/performance-config.png)

![scan-scheduling-config.png](images/task-6/scan-scheduling-config.png)

## 11. Сравнение Nmap с netcat

`netcat` — утилита Unix, позволяющая устанавливать соединения TCP и UDP, принимать оттуда данные и передавать их.
Несмотря на свою полезность и простоту, данная утилита не входит ни в какой стандарт (например, POSIX).

Формат утилиты: `nc host port`

Создает TCP-подключения с указанными реквизитами и замыканием стандартного ввода на сетевой вывод и наоборот,
стандартного вывода на сетевой ввод. При невозможности подключения программа выводит сообщение об ошибке на stderr.

Применение:

- Тестирование и ручная работа с сетевыми протоколами;
- Проверка доступности портов;
- Сканирование портов;
- Сетевой интерфейс для командного интерпретатора UNIX;
- Написание shell-сценариев эмулируюших HTTP запросы;
- Перенаправить или проксировать TCP/UDP/SCTP трафик на другие порты или хосты;
- Шифровать связь с помощью SSL и передавать её по IPv4 или IPv6;
- Выступать в качестве сетевого шлюза для выполнения системных команд с перенаправлением ввода/вывода в сеть;
- Выступать в качестве посредника соединений, позволяя двум (или даже более) клиентам подключаться друг к другу через
  третий (посреднический) сервер;
- (С флагом `-l`) создание простых серверов, обычно тестовых;
- (Совместно с `inetd`) перенаправление портов.

Эти возможности становятся ещё более мощными и универсальными в сочетании друг с другом.

Таким образом, можно сделать вывод, что netcat является более гибкой утилитой и предоставляет больше возможностей в
сравнении с Nmap, так как позволяет решать широкий спектр задач по тестированию безопасности и администрированию. Netcat
подходит для интерактивного использования или в качестве подключенного к сети бэкенда для других инструментов.

## 12. Выводы

В ходе данной работы были изучены возможности консольной утилиты Nmap для сканирования и анализа компьютерных сетей.
Данная утилита является очень гибкой и имеет множество возможных режимов работы, каждый из которых может быть полезен в
каком-то конкретном случае для получения более подробной информации о сегменте сети и о хостах.

# 7. Netcat and Cryptcat utilities

## 1. Цель работы

Исследование взаимодействия процессов на разных хостах с использованием утилит Netcat и её защищенного аналога Cryptcat.

## 2. Ход работы

Устройства, за которыми производилось исследование утилит, подключены с помощью Wi-Fi роутера к домашней сети. В таблице
ниже приведены некоторые параметры устройств в этой сети.

| Тип               | IP адрес       |
|-------------------|----------------|
| Хост с OC Linux   | 192.168.31.239 |
| Хост с ОС Windows | 192.168.31.26  |

## 3. Утилита Netcat

**Netcat** — это сетевой инструмент для чтения и записи данных через сетевые подключения с использованием TCP или UDP.

### 3.1. Netcat чат

Организуем простой чат с использованием утилиты Netcat. Для этого запустим на двух хостах два экземпляра Netcat, один из
которых будет находиться в состоянии слушателя, а второй инициировать подключение с первым. Подключение будет
производиться по порту `31337`.

**Флаги:**

- `-l` — прослушивать входящие соединения, а не инициировать подключение к удаленному хосту.
- `-p port` — устанаваливает порт прослушивания (в нашем случае `31337`).

![Chat listener](images/task-7/chat_listener.png)

![Chat connect](images/task-7/chat_connect.png)

В результате на хосте с ОС Windows был запущен слушатель, к которому в последствии подключился хост с ОС Linux. На
изображениях выше также продемонстрирован обмен сообщениями между двумя хостами.

### 3.2. Netcat передача файлов

Организуем передачу файлов с использованием утилиты Netcat. Попробуем передать текстовый файл с одного хоста на другой.
Содержимое файла представлено на рисунке ниже.

![Text file](images/task-7/text_file.png)

Для передачи файла запустим утилиту Netcat в режиме слушателя по порту 31337 на одном хосте и зададим передаваемый файл,
после чего инициируем соединение с другого хоста для получения передаваемого файла.

**Флаги:**

- `-v` — подробный режим отображения логов.
- `-l` — прослушивать входящие соединения, а не инициировать подключение к удаленному хосту.
- `-w timeout` — автоматически закрыть соединение, если соединение и stdin простаивают более *timeout* секунд.
- `-n` — не выполнять поиск имен через DNS

![File listener](images/task-7/file_listener.png)

![File connect](images/task-7/file_connect.png)

При попытке инициирования подключения у клиента появляется сообщение о том, что данный порт отрыты для этого ip адреса.
На стороне слушателя появилось сообщение о подключении клиента (по ip адресу видно, что подключился наш хост с ОС
Linux). Спустя 30 секунд бездействия произошло автоматическое закрытие соединения. В результате файл был успешно
передан.

## 4. Утилита Cryptcat

**Cryptcat** — это стандартный netcat, дополненный шифрованием twofish (симметричный алгоритм блочного шифрования с
размером блока 128 бит и длиной ключа до 256 бит).

Попробуем организовать чат с использованием утилиты cryptcat, а также проанализируем трафик с помощью сетевого снифера
Wireshark в случае защищенного и открытого соединений.

Принцип организации соединения остался таким же. Единственным отличием является наличие симметричного ключа.

**Флаги:**

- `-k keyword` — назначение симметричного ключа.

![Cryptcat listener](images/task-7/crypt_listener.png)

![Cryptcat connect](images/task-7/crypt_connection.png)

Воспользуемся сетевым снифером Wireshark и сравним трафик в случае защищенного/открытого соединения. В результате видим,
что пакеты переданные с помощью утилиты netcat в заголовке data содержат сообщения в открытом виде, что показано на
рисунке ниже.

![Netcat message](images/task-7/msg_uncrypt.png)

Cryptcat в свою очередь шифрует всю передаваемую информацию. На рисунке ниже показан пример зашифрованных данных в
заголовке data.

![Cryptcat message](images/task-7/msg_crypt.png)

## 5. Вывод

В данной работе мы познакомились с возможностями утилиты netcat и её безопасной версии cryptcat.

# 8. Firewalls, iptables rules

## 1. Цель работы

Исследование контроля и фильтрации проходящего сетевого трафика в соответствии с заданными правилами с использованием
утилиты `iptables`.

## 2. Ход работы

`iptables` — утилита командной строки, является стандартным интерфейсом управления работой межсетевого экрана
netfilter для ядер Linux. Iptables оперирует некими правилами (rules), на основании которых решается судьба пакета,
который поступил на интерфейс сетевого устройства.

### 2.1. Получение списка правил

Посмотреть текущие правила, установленные в `iptables`, можно при помощи команды: `sudo iptables -L`. Результат её
работы
представлен на рисунке ниже.

![iptables rules](images/task-8/rules_iptables.png)

### 2.2. Блокировка всего входящего трафика

Заблокируем весь входящий трафик. Для этого воспользуемся командой: `sudo iptables -A INPUT -j DROP`

**Флаги:**

- `-A chain rule-specificationУ `— добавить одно или несколько правил в конец выбранной цепочки.
- `-j target `— определить цель правила (что делать, если пакет соответствует правилу)

На рисунке ниже представлено состояние списка после добавления нового правила.

![Drop rule](images/task-8/rule_drop.png)

Вызова утилиты ping и использование браузера не дали результата. Число заблокированных пакетов можно увидеть на рисунке
ниже.

![Droped packages](images/task-8/drop_p.png)

### 2.3. Фильтрация входящего трафика

Попробуем отфильтровать весь трафик так, чтобы проходил только веб-трафик. Для этого:

1. Установим **DROP** в качестве политики по умолчанию

`sudo iptables -P INPUT DROP`

2. Разрешим трафик для loopback, чтобы внутренние сервисы нормально работали

`sudo iptables -A INPUT -i lo -j ACCEPT`

3. Теперь разрешим TCP и UDP соединения, которые сами создаем:

`sudo iptables -A INPUT -p tcp -m state --state ESTABLISHED,RELATED -j ACCEPT`

`sudo iptables -A INPUT -p udp -m state --state ESTABLISHED,RELATED -j ACCEPT`

4. Разрешим работу DNS-сервиса

`sudo iptables -A INPUT -p tcp --dport 53 -j ACCEPT`

`sudo iptables -A INPUT -p tcp --sport 53 -j ACCEPT`

`sudo iptables -A INPUT -p udp --dport 53 -j ACCEPT`

`sudo iptables -A INPUT -p udp --sport 53 -j ACCEPT`

5. Разрешим http и https

`sudo iptables -A INPUT -p tcp --dport 80 -j ACCEPT`

`sudo iptables -A INPUT -p tcp --dport 443 -j ACCEPT`

**Флаги:**

- `-A chain rule-specification` — добавить одно или несколько правил в конец выбранной цепочки.
- `-P chain target `— устанавливает политику для цепочки на заданную цель
- `-i name` — определяет имя интерфейса, через который был получен пакет
- `-j target` — определить цель правила (что делать, если пакет соответствует правилу)
- `-p protocol` — определяет протокол правила или пакета для проверки
- `--state state` — определяет состояния соединения, которым нужно соответствовать
    - **ESTABLISHED** — пакет связан с соединением, которое просматривало пакеты в обоих направлениях
    - **RELATED** — пакет запускает новое соединение, но связан с существующим соединением
- `--dport [ports]` — порт назначения является одним из заданных портов
- `--sport [ports]` — порт источника является одним из заданных портов

Итоговая таблица правил представлена на рисунке ниже

![Iptables final](images/task-8/final_rules.png)

Проверим работу нашего фильтра. Для эмуляции работы WEB-сервера используем Netcat.

![Netcat listener](images/task-8/nc_listener.png)

![Netcat client](images/task-8/nc_client.png)

В результате видим, что передача произошла без потерь.

## 3. Вывод

В ходе выполнения данной работы нами были изученные основные возможности управления цепочками правил при помощи утилиты
`iptables`.

По итогам работы нами был разработан сервер защищённый от внешних подключений.

# 9. Iptables implementation

**Цель работы:** Установка правил фильтрации исходящего трафика при помощи утилиты `iptables`.

*TODO*

# 10. Connections Limit

**Цель работы:** Ограничение количества ssh-соединений.

*TODO*

# 11. L2, L3 Sockets sniffing

**Цель работы:** Исследование возможности RAW-сокетов предоставляющих доступ к полям заголовков
сообщений протоколов уровней L2 и L3 модели OSI.

*TODO*
